;
; khan.s
; NES tribute to KHAN
; Brad Smith, 2019
; http;//rainwarrior.ca
;

USE_DPCM = 1
COL1 = 5
COL2 = 3
COL3 = 3
COL4 = 3
COLUMNS = COL1 + COL2 + COL3 + COL4 ; animated columns
ROWST = 12 ; tile rows to update
SPEED_MIN = 256/4
SPEED_MAX = 3*256
TEXT_SPEEDX = 157
TEXT_SPEEDY = 251
SINE_ROT = 180 / COLUMNS
PROFILE = 0

; ===
; RAM
; ===

.segment "ZEROPAGE"
i:           .res 1 ; temporary
j:           .res 1
pal:         .res 1 ; 0 = NTSC timing, 1 = PAL timing
nmi_now:     .res 1 ; prevents NMI reentry
mouth:       .res 1 ; count down to sample stop / mouth close
mouth_wait:  .res 2 ; count down to next auto scream
textax:      .res 2 ; text "angle" for curve
textay:      .res 2
textspr:     .res 1 ; text sprite animation
textcol:     .res 1 ; text color
textforce:   .res 1
chrsel:      .res 1 ; selects CHR pages for rendering
gamepad:     .res 1
gamepad_new: .res 1
gamepad_old: .res 1
seed:        .res 3
sound_off:   .res 1
mode:        .res 1 ; sets scroll speed table/behaviour
pause:       .res 1


.segment "BSS"
nmt:  .res (ROWST*32)
rot0: .res 16
rot1: .res 16

.assert (COLUMNS<16), error, "rot0/rot1 array size"

.segment "OAM"
.align 256
oam: .res 256

; ====
; Data
; ====

.segment "CHR"

.incbin "khan.chr"


.segment "DPCM"

; Place immediately after a labelled 64-byte aligned DPCM sample.
; Creates xxx_dpcm_addr constant for $4012
; Creates xxx_dpcm_len constant for $4013
.macro DPCM_SAMPLE label_
	.local label_dpcm
	label_dpcm = (((label_)-$C000)>>6)
	.ident(.concat(.string(label_),"_dpcm_addr")) = <label_dpcm
	.assert .ident(.concat(.string(label_),"_dpcm_addr")) = label_dpcm, error, "DPCM not in range"
	.ident(.concat(.string(label_),"_dpcm_len")) = (((*-(label_))-1)>>4)
.endmacro

.align 64
scream: .incbin "khan.dmc"
DPCM_SAMPLE scream

.align 64
silent: .byte 0
DPCM_SAMPLE silent

SCREAM_BYTES = $CE4 ; scream has this many bytes before silent zero padding at the end
DPCM_BYTE_NTSC = 72*8 ; cycles per byte at rate $E
DPCM_BYTE_PAL  = 66*8
CLOCKS_NTSC = 1789772/60
CLOCKS_PAL = 1662607/50

.segment "RODATA"

scream_frames: ; how many frames does a scream last before we should silence it
.byte 4 + (SCREAM_BYTES * DPCM_BYTE_NTSC / CLOCKS_NTSC)
.byte 4 + (SCREAM_BYTES * DPCM_BYTE_PAL  / CLOCKS_PAL )

; tables generated by build_data.py
.include "tables.inc"
; sin
; sinx - for x
; siny

palette:
.byte $0F, $0F, $0F, $0F
.byte $0F, $0F, $05, $00
.byte $0F, $05, $16, $10
.byte $0F, $06, $26, $30
.byte $0F, $0F, $0F, $0F
.byte $0F, $01, $11, $21
.byte $0F, $02, $12, $22
.byte $0F, $03, $13, $23

attribute_row: ; same row used for all visible rows
.byte %01000100, %10101010, %10101010, %11101110, $FF, $FF, $FF, $FF

; speed of each column

.assert COLUMNS <= 16, error, "speed tables are packed in 16, too many columns"

speed0:
.repeat 16, I ; default
	;.byte <(SPEED_MIN+(((SPEED_MAX-SPEED_MIN)*I)/(COLUMNS-1))) ; linear
	.byte <(SPEED_MIN+(((SPEED_MAX-SPEED_MIN)*(I*I))/((COLUMNS-1)*(COLUMNS-1)))) ; quadratic
.endrepeat
.repeat 16, I ; reverse
	.byte <-(SPEED_MIN+(((SPEED_MAX-SPEED_MIN)*(I*I))/((COLUMNS-1)*(COLUMNS-1))))
.endrepeat
.repeat 8, I ; alternate
	.byte <(SPEED_MIN+(((SPEED_MAX-SPEED_MIN)*(4*I*I))/((COLUMNS-1)*(COLUMNS-1))))
	.byte <-(SPEED_MIN+(((SPEED_MAX-SPEED_MIN)*(2+(4*(I*I+I))))/((COLUMNS-1)*(COLUMNS-1))))
.endrepeat
.repeat 16 ; stop
	.byte 0
.endrepeat

speed1:
.repeat 16, I ; default
	;.byte >(SPEED_MIN+(((SPEED_MAX-SPEED_MIN)*I)/(COLUMNS-1)))
	.byte >(SPEED_MIN+(((SPEED_MAX-SPEED_MIN)*(I*I))/((COLUMNS-1)*(COLUMNS-1))))
.endrepeat
.repeat 16, I ; reverse
	.byte >-(SPEED_MIN+(((SPEED_MAX-SPEED_MIN)*(I*I))/((COLUMNS-1)*(COLUMNS-1))))
.endrepeat
.repeat 8, I ; alternate
	.byte >(SPEED_MIN+(((SPEED_MAX-SPEED_MIN)*(4*I*I))/((COLUMNS-1)*(COLUMNS-1))))
	.byte >-(SPEED_MIN+(((SPEED_MAX-SPEED_MIN)*(2+(4*(I*I+I))))/((COLUMNS-1)*(COLUMNS-1))))
.endrepeat
.repeat 16 ; stop
	.byte 0
.endrepeat

; width of each column

width:
.repeat COL1
	.byte 1
.endrepeat
.repeat COL2
	.byte 2
.endrepeat
.repeat COL3
	.byte 3
.endrepeat
.repeat COL4
	.byte 4
.endrepeat

; modulo of each column

mod:
.repeat COL1
	.byte 8
.endrepeat
.repeat COL2
	.byte 16
.endrepeat
.repeat COL3
	.byte 24
.endrepeat
.repeat COL4
	.byte 32
.endrepeat

; base tile of each tile column

BASE1 = $F8
BASE2 = $D8
BASE3 = $90
BASE4 = $10

baset:
.repeat COL1
	.byte BASE1
.endrepeat
.repeat COL2
	.byte BASE2, BASE2+16
.endrepeat
.repeat COL3
	.byte BASE3, BASE3+24, BASE3+48
.endrepeat
.repeat COL4
	.byte BASE4, BASE4+32, BASE4+64, BASE4+96
.endrepeat
.assert (*-baset)=32, error, "baset size"

; modulo of each tile column, baked into tables

;modt1:
;.repeat 8, I
;	.byte BASE1 + ((I+(8-8)) .MOD  8)
;.endrepeat

modt2:
.repeat 16, I
	.byte BASE2 + ((I+(16-8)) .MOD 16)
.endrepeat
.repeat 16, I
	.byte BASE2 + 16 + ((I+(16-8)) .MOD 16)
.endrepeat

modt3:
.repeat 24, I
	.byte BASE3 + ((I+(24-8)) .MOD 24)
.endrepeat
.repeat 24, I
	.byte BASE3 + 24 + ((I+(24-8)) .MOD 24)
.endrepeat
.repeat 24, I
	.byte BASE3 + 48 + ((I+(24-8)) .MOD 24)
.endrepeat

modt4:
.repeat 32, I
	.byte BASE4 + ((I+(32-8)) .MOD 32)
.endrepeat
.repeat 32, I
	.byte BASE4 + 32 + ((I+(32-8)) .MOD 32)
.endrepeat
.repeat 32, I
	.byte BASE4 + 64 + ((I+(32-8)) .MOD 32)
.endrepeat
.repeat 32, I
	.byte BASE4 + 96 + ((I+(32-8)) .MOD 32)
.endrepeat

; =========
; Animation
; =========

animate:
	jsr prng_init ; initialize seed if needed
	; poll gamepad
	lda gamepad
	sta gamepad_old
	jsr gamepad_poll
	eor gamepad_old
	and gamepad
	sta gamepad_new
	; animate text
	inc textspr ; CHR page animation for text
	lda textax+0
	clc
	adc #<TEXT_SPEEDX
	sta textax+0
	lda textax+1
	adc #>TEXT_SPEEDX
	sta textax+1
	lda textay+0
	clc
	adc #<TEXT_SPEEDY
	sta textay+0
	lda textay+1
	adc #>TEXT_SPEEDY
	sta textay+1
	lda textspr ; cycle colour every 4 frames
	and #3
	bne :++
		lda textcol
		clc
		adc #1
		cmp #$2D
		bcc :+
			lda #$21
		:
		sta textcol
	:
	; mouth timer for scream
	lda mouth
	beq @mouth_off
		dec mouth
		bne @mouth_end
		jsr mouth_wait_reload
	@mouth_off:
		jsr play_silent
	@mouth_end:
	; decide whether to scream
	lda gamepad ; hold B for continual soundless scream (also turns off sound)
	and #PAD_B
	beq :+
		lda #1
		sta sound_off
		jsr do_scream
	:
	lda gamepad_new
	and #PAD_A ; press A for one time scream (also turns on sound)
	beq :+
		lda #0
		sta sound_off
		jsr do_scream
	:
	lda mouth
	bne @scream_end ; already screaming
	lda mouth_wait+0
	ora mouth_wait+1
	beq @scream_on ; wait timer finished
	lda mouth_wait+0
	bne :+
		dec mouth_wait+1
	:
	dec mouth_wait+0
	jmp @scream_end ; decrement wait timer and continue
	@scream_on:
		jsr do_scream
	@scream_end:
	; select toggles forced text, start pauses motion
	lda gamepad_new
	and #PAD_SELECT
	beq :+
		lda textforce
		eor #1
		sta textforce
	:
	lda gamepad_new
	and #PAD_START
	beq :+
		lda pause
		eor #1
		sta pause
	:
	; d-pad and start adjust mode of parallax
	lda gamepad_new
	and #PAD_D
	beq :+
		lda #0
		sta mode
	:
	lda gamepad_new
	and #PAD_U
	beq :+
		lda #16
		sta mode
	:
	lda gamepad_new
	and #PAD_L
	beq :+
		lda #32
		sta mode
	:
	lda gamepad_new
	and #PAD_R
	beq :+
		lda #64 ; sine mode
		sta mode
	:
	; animate parallax
	lda mode
	pha
	lda pause
	beq :+
		lda #48
		sta mode ; pause overrides mode with halted mode
	:
	jsr do_parallax
	pla
	sta mode
	; select CHR pages
	lda mouth
	cmp #1
	lda #0
	ror
	ror
	ror
	ror
	eor #%00010000
	sta chrsel ; mouth>1 selects page 0 background, otherwise page 1
	lda textspr
	asl
	and #%00001000
	ora chrsel
	sta chrsel ; textspr flips text page every 8 frames (doesn't actually affect tall sprites though...)
	rts

do_parallax:
	lda mode
	cmp #64
	bcs do_parallax_sine
	ldx #0
	stx j ; tile index
	@loop:
		txa
		clc
		adc mode
		tay
		; add speed to rot
		lda rot0, X
		clc
		adc speed0, Y
		sta rot0, X
		lda rot1, X
		adc speed1, Y
		bpl @mod_positive
		@mod_negative:
			clc
			adc mod, X
			jmp @mod_end
		@mod_positive:
			cmp mod, X
			bcc :+
				;sec
				sbc mod, X
			:
		@mod_end:
		sta rot1, X
		; copy rot to first row of nmt
		ldy width, X
		:
			sty i
			ldy j ; tile index
			clc
			adc baset, Y
			sta nmt, Y
			sec
			sbc baset, Y
			iny
			sty j
			ldy i
			dey
			bne :-
		inx
		cpx #COLUMNS
		bcc @loop
	rts

do_parallax_sine:
	lda textay+1
	sta mode ; since mode is preserved on stack, reusing for temporary angle
	ldx #0
	stx j
	@loop:
		ldy mode
		; add sine<<3 to rot (signed)
		lda sin, Y
		asl
		asl
		asl
		clc
		adc rot0, X
		sta rot0, X
		php ; temporarily store carry
		lda sin, Y
		php ; temporarily store sign
		lsr
		lsr
		lsr
		lsr
		lsr
		plp
		bpl :+
			ora #%11111000 ; extend sign
		:
		plp
		adc rot1, X
		bpl @mod_positive
		@mod_negative:
			clc
			adc mod, X
			bmi @mod_negative ; keep going if needed
			jmp @mod_end
		@mod_positive:
			cmp mod, X
			bcc :++
			:
				;sec
				sbc mod, X
				bcc :- ; keep going if needed
			:
		@mod_end:
		sta rot1, X
		; copy rot to first row of nmt
		ldy width, X
		:
			sty i
			ldy j ; tile index
			clc
			adc baset, Y
			sta nmt, Y
			sec
			sbc baset, Y
			iny
			sty j
			ldy i
			dey
			bne :-
		; advance rotation
		lda mode
		clc
		adc #SINE_ROT
		sta mode
		; next
		inx
		cpx #COLUMNS
		bcc @loop
	rts

do_scream:
	ldx pal
	lda scream_frames, X
	sta mouth
	lda sound_off
	bne :+
		jmp play_scream
	:
		jmp play_silent
	;

mouth_wait_reload:
	jsr prng
	sta mouth_wait+0
	jsr prng
	and #7 ; wait up to ~30 seconds between screams
	sta mouth_wait+1
	rts

.if USE_DPCM

play_silent:
	lda #%00000000 ; sample off
	sta $4015
	lda #$4E ; looped, rate $E
	sta $4010
	lda #silent_dpcm_addr
	sta $4012
	lda #silent_dpcm_len
	sta $4013
	lda #%00010000 ; sample on
	sta $4015
	rts

play_scream:
	lda #%00000000
	sta $4015
	lda #$4E
	sta $4010
	lda #scream_dpcm_addr
	sta $4012
	lda #scream_dpcm_len
	sta $4013
	lda #%00010000
	sta $4015
	rts

.else

play_silent:
play_scream:
	rts

.endif

draw_text:
	lda textforce
	bne @text_on
	lda mouth
	beq @text_off
@text_on:
	; starting X/Y coordinate
	ldx textax+1
	lda sinx, X
	sta i
	ldx textay+1
	lda siny, X
	sta j
	; jitter
	jsr prng2
	and #3
	bne :+ ; jitter 1/4 frames
		jsr prng2
		and #3
		clc
		adc i
		sta i
		jsr prng2
		and #3
		clc
		adc j
		sta j
	:
	; build sprite
	ldy #0
	lda chrsel ; transfer sprite chrsel to low bit of Y
	and #%00001000
	beq :+
		iny
	:
	ldx #(8*4)
	:
		lda j
		sta oam+0, X
		tya
		sta oam+1, X
		lda #3
		sta oam+2, X
		lda i
		sta oam+3, X
		clc
		adc #8
		sta i
		inx
		inx
		inx
		inx
		iny
		iny
		cpy #(8*2)
		bcc :-
	rts
@text_off:
	lda #$FF
	ldy #0
	ldx #(8*4)
	:
		sta oam+0, X
		inx
		inx
		inx
		inx
		iny
		cpy #8
		bcc :-
	rts

.macro NMT_ROW1 nmt_, index_
	lda nmt_+index_, Y
	sta nmt_+index_+32, Y
.endmacro

.macro NMT_ROW2 nmt_, index_
	ldx nmt_+index_, Y
	lda modt2-BASE2, X
	sta nmt_+index_+32, Y
	ldx nmt_+index_+1, Y
	lda modt2-BASE2, X
	sta nmt_+index_+33, Y
.endmacro

.macro NMT_ROW3 nmt_, index_
	ldx nmt_+index_, Y
	lda modt3-BASE3, X
	sta nmt_+index_+32, Y
	ldx nmt_+index_+1, Y
	lda modt3-BASE3, X
	sta nmt_+index_+33, Y
	ldx nmt_+index_+2, Y
	lda modt3-BASE3, X
	sta nmt_+index_+34, Y
.endmacro

.macro NMT_ROW4 nmt_, index_
	ldx nmt_+index_, Y
	lda modt4-BASE4, X
	sta nmt_+index_+32, Y
	ldx nmt_+index_+1, Y
	lda modt4-BASE4, X
	sta nmt_+index_+33, Y
	ldx nmt_+index_+2, Y
	lda modt4-BASE4, X
	sta nmt_+index_+34, Y
	ldx nmt_+index_+3, Y
	lda modt4-BASE4, X
	sta nmt_+index_+35, Y
.endmacro

nmt_row0:
	; Y = first tile
	.repeat COL1, I
		NMT_ROW1 nmt, I
	.endrepeat
	.repeat COL2, I
		NMT_ROW2 nmt, (COL1+(2*I))
	.endrepeat
	.repeat COL3, I
		NMT_ROW3 nmt, (COL1+(2*COL2)+(3*I))
	.endrepeat
	.repeat COL4, I
		NMT_ROW4 nmt, (COL1+(2*COL2)+(3*COL3)+(4*I))
	.endrepeat
	tya
	clc
	adc #32
	tay
	rts

nmt_row1:
	; Y = first tile
	.repeat COL1, I
		NMT_ROW1 nmt+256, I
	.endrepeat
	.repeat COL2, I
		NMT_ROW2 nmt+256, (COL1+(2*I))
	.endrepeat
	.repeat COL3, I
		NMT_ROW3 nmt+256, (COL1+(2*COL2)+(3*I))
	.endrepeat
	.repeat COL4, I
		NMT_ROW4 nmt+256, (COL1+(2*COL2)+(3*COL3)+(4*I))
	.endrepeat
	tya
	clc
	adc #32
	tay
	rts

nmt_rows:
	ldy #0
	.repeat (256/32)
		jsr nmt_row0
	.endrepeat
	.assert (ROWST*32)>256, error, "ROWST size too large"
	.repeat ROWST-(1+(256/32))
		jsr nmt_row1
	.endrepeat
	.assert (ROWST*32)<512, error, "ROWST size too lage"
	rts

.segment "ALIGN"

; upload nmt buffer to $2007
; aligned for fixed timing
.align 256
nmt_apply:
	; would normally unroll this, but the 48 line forced blank is pretty generous
	ldx #0
	:
		lda nmt, X
		sta $2007
		inx
		bne :-
	.assert (ROWST*32)>256, error, "ROWST size too large"
	:
		lda nmt+256, X
		sta $2007
		inx
		cpx #((ROWST*32)-256)
		bcc :-
	.assert (ROWST*32)<512, error, "ROWST size too lage"
	rts

; X/Y scroll split at a fixed x/y/nametable
.macro SCROLL_SPLIT x_, y_, n_
	lda #((y_ & %11000000) >> 6) | ((y_ & %00000011) << 4) | (n_ << 2)
	sta $2006
	lda #y_
	sta $2005
	lda #x_
	sta $2005
	lda #((x_ & %11111000) >> 3) | ((y_ & %00111000) << 2)
	sta $2006
.endmacro

; timed rendering code with forced black
; 16:9 letterboxing (48 lines of blank at top and bottom)
; aligned for fixed timing
.align 256
render:
	; forced blank
	lda #%00000000
	sta $2001
	lda pal
	beq :+
		jsr oam_dma ; PAL should OAM DMA at start of NMI blank
	:
	bit $2002
	; animated text colour
	lda #$3F
	sta $2006
	lda #$1F
	sta $2006
	lda textcol
	sta $2007
	; nametable update
	lda #$20
	sta $2006
	lda #$00
	sta $2006
	jsr nmt_apply
	jsr render_wait0
	lda pal
	bne :+
		jsr oam_dma ; NTSC should OAM DMA at end of forced blank
	:
	; set CHR page and other $2000 properties
	lda chrsel
	and #%00011000
	ora #%10100000 ; NMI on, tall sprites, +1 increment, nametable 00
	sta $2000
	SCROLL_SPLIT 8,48,0
	; unblank
	lda #%00011110
	sta $2001 ; line 47 hblank > dot 257
	.assert ROWST=12, error, "render timing needs adjustment"
	jsr render_wait1
	SCROLL_SPLIT 8,0,0  ; line 95 hblank > dot 257
	rts

.if USE_DPCM
; DPCM sample fetch adds cycles, delays must be adjusted
; These are tuned specifically for sample rate $E

render_wait0:
	lda pal
	bne @pal
@ntsc:
	jsr delay_1536
	jsr delay_192
	jsr delay_96
	nop
	nop
	nop
	rts
@pal:
	jsr delay_6144
	jsr delay_384
	jsr delay_96
	nop
	nop
	nop
	rts

render_wait1:
	lda pal
	bne @pal
@ntsc:
	jsr delay_3072
	jsr delay_1536
	jsr delay_768
	rts
@pal:
	jsr delay_3072
	jsr delay_1536
	jsr delay_384
	jsr delay_24
	jsr delay_12
	nop
	nop
	nop
	nop
	rts

.else

render_wait0:
	lda pal
	bne @pal
@ntsc:
	jsr delay_1536
	jsr delay_192
	jsr delay_96
	jsr delay_48
	nop
	nop
	rts
@pal:
	jsr delay_6144
	jsr delay_384
	jsr delay_96
	jsr delay_48
	jsr delay_24
	jsr delay_12
	nop
	nop
	nop
	nop
	rts

render_wait1:
	lda pal
	bne @pal
@ntsc:
	jsr delay_3072
	jsr delay_1536
	jsr delay_768
	jsr delay_24
	jsr delay_12
	nop
	rts
@pal:
	jsr delay_3072
	jsr delay_1536
	jsr delay_384
	jsr delay_48
	jsr delay_24
	nop
	nop
	nop
	nop
	nop
	rts

.endif

oam_dma:
	lda #0
	sta $2003
	lda #>oam
	sta $4014
	rts

; some compact cycle delay routines
delay_24576: jsr delay_12288
delay_12288: jsr delay_6144
delay_6144:  jsr delay_3072
delay_3072:  jsr delay_1536
delay_1536:  jsr delay_768
delay_768:   jsr delay_384
delay_384:   jsr delay_192
delay_192:   jsr delay_96
delay_96:    jsr delay_48
delay_48:    jsr delay_24
delay_24:    jsr delay_12
delay_12:    rts

; =========
; Utilities
; =========

.segment "CODE"

PAD_A      = $01
PAD_B      = $02
PAD_SELECT = $04
PAD_START  = $08
PAD_U      = $10
PAD_D      = $20
PAD_L      = $40
PAD_R      = $80

gamepad_poll_: ; standard single read
	lda #1
	sta $4016
	lda #0
	sta $4016
	ldx #8
	:
		pha
		lda $4016
		and #%00000011
		cmp #%00000001
		pla
		ror
		dex
		bne :-
	sta gamepad
	rts

gamepad_poll: ; DPCM safe read-until-consistent
	jsr gamepad_poll_
	:
		lda gamepad
		pha
		jsr gamepad_poll_
		pla
		cmp gamepad
		bne :-
	cmp #0 ; refresh flags
	rts

prng_init: ; initialize seed if it's currently at 0
	lda seed+0
	ora seed+1
	ora seed+2
	bne :+
		lda #$80
		sta seed+2
	:
	rts

prng:
	ldy #8
prngy:
	lda seed+0
:
	asl
	rol seed+1
	rol seed+2
	bcc :+
	eor #$1B
:
	dey
	bne :--
	sta seed+0
	cmp #0
	rts

prng2:
	ldy #2
	jmp prngy

.segment "ALIGN"

; Detects NTSC vs PAL
; http://forums.nesdev.com/viewtopic.php?p=163258#p163258
; A = 0 NTSC
;     1 PAL
;     2 Dendy
;     3+ ?
.align 32
cpu_speed_detect:
	; count increments between 2 vblanks
	ldx #0
	ldy #0
	bit $2002
:
	bit $2002
	bpl :-
:
	inx
	bne :+
		iny
	:
	bit $2002
	bpl :--
	; compensate for a double-frame in case $2002 was accidentally suppressed once
	tya
	cmp #16
	bcc :+
	lsr
:
	sec
	sbc #9
	rts

; ====
; Main
; ====

.segment "CODE"

nmi:
	pha
	txa
	pha
	tya
	pha
	lda nmi_now
	bne :+
		lda #1
		sta nmi_now
		jsr render
		jsr animate
		jsr nmt_rows
		jsr draw_text
		.if PROFILE
			lda #%00011111
			sta $2001 ; greyscale profiling
		.endif
		lda #0
		sta nmi_now
	:
	pla
	tay
	pla
	tax
	pla
	rti

irq:
	; not used
	rti

reset:
	sei       ; disable maskable interrupts
	lda #0
	sta $2000 ; disable non-maskable interrupt
	lda #0
	sta $2001 ; rendering off
	sta $4010 ; disable DMC IRQ
	sta $4015 ; disable APU sound
	lda #$40
	sta $4017 ; disable APU IRQ
	cld       ; disable decimal mode
	ldx #$FF
	txs       ; setup tack
	; wait for vblank #1
	bit $2002
	:
		bit $2002
		bpl :-
	; preserve positions/random stuff on reset
	ldx #0
	:
		lda rot1, X
		pha
		inx
		cpx #COLUMNS
		bcc :-
	lda seed+0
	pha
	lda seed+1
	pha
	lda seed+2
	pha
	lda textax+1
	pha
	lda textay+1
	pha
	; clear RAM
	lda #0
	tax
	:
		sta $0000, X
		;sta $0100, X ; don't clear stack yet
		sta $0200, X
		sta $0300, X
		sta $0400, X
		sta $0500, X
		sta $0600, X
		sta $0700, X
		inx
		bne :-
	; restore positions/random stuff from stack
	pla
	sta textay+1
	pla
	sta textax+1
	pla
	sta seed+2
	pla
	sta seed+1
	pla
	sta seed+0
	ldx #COLUMNS
	@loop:
		pla
		dex
		: ; make sure within modulus range
			cmp mod, X
			bcc :+
			;sec
			sbc mod, X
			jmp :-
		:
		sta rot1, X
		cpx #0
		bne @loop
	; clear stack, separately wipe OAM
	lda #0
	:
		sta $0100, X
		inx
		bne :-
	lda #$FF
	:
		sta oam, X
		inx
		bne :-
	; wait for vblank #2
	:
		bit $2002
		bpl :-
	; ready
	;jmp main

main:
	jsr cpu_speed_detect
	cmp #1
	beq :+
		lda #0 ; anything not PAL is assumed NTSC
	:
	sta pal
	; wipe nametables
	bit $2002
	lda #$20
	sta $2006
	lda #$00
	sta $2006
	;lda #0
	tax
	ldy #16
	:
		sta $2007
		inx
		bne :-
		dey
		bne :-
	; load palettes
	lda #$3F
	sta $2006
	lda #$00
	sta $2006
	ldx #0
	:
		lda palette, X
		sta $2007
		inx
		cpx #32
		bcc :-
	; load attributes
	lda #$23
	sta $2006
	lda #$C0
	sta $2006
	ldy #3
	ldx #0
	:
		lda attribute_row, X
		sta $2007
		inx
		cpx #8
		bcc :-
		ldx #0
		dey
		bne :-
	; setup initial stuff
	jsr prng_init
	jsr mouth_wait_reload
	lda #$21
	sta textcol
	; fill render data for first frame
	jsr animate
	jsr nmt_rows
	jsr draw_text
	; place 8 black blocking sprites on line 192 (to fake forced blanking on lower screen)
	ldx #0
	:
		lda #191
		sta oam+0, X
		lda #$30 ; a conveniently solid tile
		sta oam+1, X
		lda #$00
		sta oam+2, X
		sta oam+3, X
		inx
		inx
		inx
		inx
		cpx #(8*4)
		bcc :-
	; turn on NMI
	lda #%10000000
	sta $2000
	; infinite loop
:
	jmp :-

; =======
; NES ROM
; =======

.segment "HEADER"

INES_MAPPER     = 0 ; NROM
INES_MIRROR     = 0 ; vertical nametables
INES_PRG_16K    = 1 ; 16K
INES_CHR_8K     = 1 ; 8K
INES_BATTERY    = 0
INES2           = %00001000 ; NES 2.0 flag for bit 7
INES2_SUBMAPPER = 0
INES2_PRGRAM    = 0
INES2_PRGBAT    = 0
INES2_CHRRAM    = 0
INES2_CHRBAT    = 0
INES2_REGION    = 2 ; 0=NTSC, 1=PAL, 2=Dual

; iNES 1 header
.byte 'N', 'E', 'S', $1A ; ID
.byte <INES_PRG_16K
.byte INES_CHR_8K
.byte INES_MIRROR | (INES_BATTERY << 1) | ((INES_MAPPER & $f) << 4)
.byte (<INES_MAPPER & %11110000) | INES2
; iNES 2 section
.byte (INES2_SUBMAPPER << 4) | (INES_MAPPER>>8)
.byte ((INES_CHR_8K >> 8) << 4) | (INES_PRG_16K >> 8)
.byte (INES2_PRGBAT << 4) | INES2_PRGRAM
.byte (INES2_CHRBAT << 4) | INES2_CHRRAM
.byte INES2_REGION
.byte $00 ; VS system
.byte $00, $00 ; padding/reserved
.assert * = 16, error, "NES header must be 16 bytes."

.segment "VECTORS"
.word nmi
.word reset
.word irq

; end of file
